깃은 특정시점의 사용자의 프로그램 코드를 사진을 찍듯이 저장하는 기법이고, 
덕분에 어떤 프로그램의 특정시점의 파일을 언제든지 열람하고 복구 할 수 있게 함.

깃과 깃허브를 통해서 특정시점의 코드의 상태와 업데이트자 들을 열람하고 코드의 개발을 트랙킹할 수 있다.


- git init - 빈 깃 폴더를 만듬(시작할때, .git 폴더가 만들어짐)
- git status- 폴더 내의 트랙킹이 안 되고 있는 파일들을 알려줌(프로잭트 히스토리에 포함이 안돼있기 때문에 전세계 아무도 모름)
- git log - 이때까지 커밋 된 히스토리를 보여줌
- git reset [커밋 로그의 해쉬] - 그 당시 커밋했을때의 상태로 돌려놓음
- git stash- 이미 add한 파일중에 당장 커밋하고 싶지 않지만 특정 장소에 저장해놓고 나중에 빼먹고 싶을때 사용
- git stash pop - 스태쉬 된 친구들 호출
- git stash clear- 스태쉬 된 친구들 다 죽이기
- git remote add (url의 이름=origin)  (url of github) - 원격저장소의 url와 현재 폴더 연결
- git remote -v - 현재 폴더와 연결 된 원격저장소들 호출
- git push (origin) (branch name)- origin의 이름을 가진 원격저장소의 branch name에 푸쉬 함

	github에 있는 임의의 저장소의 프로젝트에 모든사람들이 커밋할 수 있으면 굉장히 위험해질 것임
	그럴때 해당 레포지토리의 파일들을 포크 떠서 자신의 계정으로 가져올 수 있음
	그러면 레포지토리가 자신의 명의로 생성되기 때문에 클론, 커밋을 자유롭게 할 수 있음 	

-  git add upstream - 포크해서 가져온 파일의 오리진 레포지토리를 로컬 리포지토리에 추가할 수 있음
	이때  클론한 파일에서 새로운 브랜치를 생성하고, 변경을 한 경우, 변경한 사항을 레포지터리에 추가시키고 싶은경우(open source) pull request 를 통해서 진행 할 수 있음


로컬 레포지토리의 브랜치는 브랜치별 오직 하나의 pull request만 줄 수 있기 때문에, 기능이나 파트별로 개별 브랜치를 만드는 것이 중요함.

	upstream에 있는 브랜치는 지속적으로 업데이트 되는데, 포크뜬 로컬 브랜치가 이를 못따라갈
	경우가 있음
	
- git fetch --all --prune - 원격저장소에 있는것들을 받아오고, 이미 원격에서 삭제된 폴더들은 로컬에서도 삭제시킴
- git reset --hard upstream/main - upstream의 메인 브랜치와 완전 동일하게 동기화 시킴
- git pull upstream main- upstream에 있는 메인 파일을 받아오기 
비싸노
- git rebase -i (hash) -여러개로 분할 된 커밋들을 하나의 커밋으로 합칠 수 있음
- git merge






  