쿠버네티스 운영환경에서 내부의 어플리케이션의 충돌로 실행이 종료될 경우, 컨테이너 내부에서 저장 되던 데이터는 모두 유실된다.
이는 컨테이너 특성상, os와 어플케이션의 상태로 저장 된 이미지 이후의 데이터는 이미지에 따로업데이트 되지 않기 때문인데, 만약 중요한 데이터를 처리하던 중 컨테이너가 종료 된다면, 새로운 컨테이너를 시작하여 컨테이너에 다시 연결 할 수 있지만, 정작 중요한 데이터는 유실 될 가능성이 크다.

이를 위해 컨테이너의 생애주기와 상관없이 이미지의 상단 계층에 따로 추가되어 관리할 수 있는 스토리지를 사용할 필요가 있다.

```
spec:
  containers:
    - name: sleep
      image: {image name}
      volumeMounts:
       - name: data
         mountPath: /data # 볼륨을 /data에 마운트
volumes:
  - name: data
    emptyDir: {} # empty Dir을 마운트 함
```
위와 같이 빈 디렉터리를 마운트 할 수 있고, 여기의 데이터는 파드가 재시작 되더라도 유지된다.

공 디렉토리는 임시 저장의 목적을 가지는 모든 애플리케이션에서 유효할 수 있다. 예를 들에 api등의 로컬 캐시등에서.
공디렉토리는 파드와 생애주기를 같이 하기 때문에 컨테이너가 일시적으로 다운된 경우 데이터를 보존하는데 효과적일 수 있지만, 새로운 파드가 생기는 경우에는 빈 디렉토리로 초기화 된다.


#### 노드에 데이터 저장하기

노드에 데이터를 저장하게 된다면, 그 특정 파드는 같은 노드에만 배치가 되어야 된다는 의미고, 그렇지 않은 경우에는 어느 노드에나 배치 될 수 있다는 의미다.
그렇기 때문에 자신의 어플리케이션에 맞는 전략을 찾는것이 중요하다.

###### 특정 디렉토리를 가리키는 볼륨
앞서서 보았던 경우처럼 특정 디렉토리를 볼륨으로 지정하여 데이터를 저장할 수 있다. 이와 같은 방법은 프록시 서버와 같은 경우에 적합하다.
데이터의 중요도가 높지 않기 때문에 설령 파드가 종료되어 데이터가 삭제 되었다고 하더라도 데이터를 가져오는 속도가 약간 줄어들 뿐, 서비스에 큰 지장은 없기 때문이다.

###### 호스트 경로 볼륨
호스트 경로(hostpath)볼륨은 노드의 디스크를 가리키는 볼륨으로 공디렉터리 보다 오래 유지되는 특징을 가지고 있다.
아래와 같이 사용할 수 있다.
```
spec:
  container:
  - image: {image}
    name: {name}
    ports:
    - containerPort:80
    volumeMounts:
    - name: cache-volume
      mountPath: {path}
volumes:
  - names: {volume name}
    hostPath:
      path:{path} # 사용할 노드의 디렉터리
      type: DirectoryOrCreate # 디렉토리가 없으면 생성
```

이렇게 사용한다면 같은 노드에서 사용하는 한, 데이터의 생애 주기는 노드의 디스크의 생애주기와 같아진다. 새로 생성되는 파드는 해당 볼륨에서 데이터를 읽어들인다.

###### 영구 볼륨과 영구 볼륨 클레임
앞서 살펴본 형식들에서는 여러 노드 환경에서 데이터의 동기화의 문제가 항상 존재하였다. 분산 스토리지를 위해 다양한 솔루션이 존재하는데 AKS 나 EKS를 사용할 수도 있고, 온프레미스 환경에서는 NFS나 글러스터FS를 사용할 수 있다.

**영구 볼륨**
영구볼륨은 사용가능한 스토리지 조각을 정의한 쿠버네티스 리소스이다.
아래와 같이 클러스터 관리자에 의해 정의될 수 있다.
```
apiVersion: V1
kind: PersistentVolume
metadata: 
  name: pv01
spec:
  capacity:
    sotrage: 50Mi
  accessModes: # 파드의 접근 유형
  - ReadWriteOnce  #파드 하나에서만 사용가능
  nfs:   # nfs 스토리지를 사용함
    server: nfs.my.network   # nfs서버의 도메인 네임
    path: "/kubernetes-volumes"  # 스토리지 경로
    
```

그러나 이와 같이 영구 볼륨이 생겼지만, 파드에서 직접 사용하지는 못한다.
영구볼륨클레임(Persistent Volume Claim)이란 것을 사용해서 볼륨사용을 요청해야한다.
pvc는 요구조건이 일치하는 영구볼륨과 함께 쓰인다.
```
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: postgres-pvc
spec:
  accessModes:  # 필수적으로 접근유형을 명시하여야 함
    - ReadWriteOncd
  resources:
    requests:
      storage: 40Mi #요청하는 스토리지 용량
  storageClassName: "" 


```
- 영구 볼륨 클레임 yaml파일
영구볼륨클레임은 영구 볼륨과 1대1로 연결되고, 한번 연결 된 볼륨은 다른 영구볼륨 클레임과 연결 될 수 없다.
영구 볼륨 클레임 또한 실행되는 순간 알맞는 영구 볼륨을 찾기 시작하고, 어떤 영구 볼륨도 없을 경우 대기생태로 있게 된다.

이런 경우 영구 볼륨 클레임을 참조하는 파드 또한 정상적으로 실행 될 수 없기 때문에 주의가 필요하다.

```
spec:
  container:
  - name: db
    image: postgres:11.6-alpine
    volumeMounts:
    - name: data
      mountPath: /~~
  volumes:
  - name: data
    persistentVolumeClaim: # 영구 클레임을 볼륨으로 쓰겠다.
      claimName: {영구 클레임의 이름}
```
이런식으로 앱도 정의 할 수 있다.

### 동적 볼륨 프로비저닝
위와 같이 정적으로 영구볼륨과 볼륨클레임을 미리 선언하여 사용할 수도 있지만, 스토리지의 접근이 상대적으로 자유로운 조직에서는 동적 볼륨 프로비저닝을 사용할 수 있다.
여기서는 영구볼륨클레임을 미리 선언하면 클러스터에서 그에 맞는 클러스터를 동적으로 생성해주는 방식이다.

``` 
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: postgres-pvc-dynamic
spec:
  accessMode:
  - ReadWriteOnce
resources:
  requests:
    sotrage: 100Mi
```
클러스터와 파일정의에 의해 다양한 형태의 볼륨의 동적으로 생성되는데
- provisioner: 영구볼륨을 만드는 주체, 플랫폼에 따라 다르다.
- reclaimPolicy: 클레임을 삭제했을때, 영구 볼륨을 어떻게 할지.
- volumeBindingMode: 영구 볼륨의 생성시기, 클레임의 생성직후가 될 수 있고, 파드의 생성직후가 될 수 있다.


아래와 같이 정리 할 수 있다.
- 컨테이너 내부에서 작성.
  읽기모드인 이미지 층의 최상단에 작성 됨. 컨테이너 내부의 파일 시스템에서 저장됨.
  컨테이너 종료 시 데이터가 휘발 됨.
- 공 디렉토리
  파드가 스케줄링 할때 생성 됨. 컨테이너가 오류로 종료되어도 데이터는 보존 할 수 있지만, 파드 자체가 종료 되는 경우 데이터가 휘발 됨.
- 호스트 패스
  노드상의 디스크에 데이터가 저장됨. 그러나 노드 컴퓨터에 데이터가 저장되는 방식이기 때문에 여러 노드상에서의 데이터 불일치, 컨테이너와 호스트 파일 시스템이 공유 됨 으로 써 보안상의 위험성이 높아진다. subPath를 정의함으로 써 제한 을 둘 수 있지만 충분하지는 않다. 
- 영구 볼륨, 영구 볼륨 클레임
  NFS등의 분산 스토리지를 추상화 할 수 있고, 추상화 하여 만든 스토리지에 영구 볼륨 클레임을 선언하여 연결 할 수 있다. 스토리지 접근 제약이 큰 조직에서 선호하는 방식이다.


