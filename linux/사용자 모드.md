[[linux 개요]]에서 사용자 모드와 커널 모드 확인.

리눅스에서 커널은 메모리 접근, 스케줄링, 프로세스 관리등 컴퓨터 시스템에 직접적으로 영향을 미칠 수 있는 동작들(프로세스들 간의 분리를 방해하고, 시스템을 파괴할수도 있는)을 커널에서 처리하고, 그런 행동들은 OS 라이브러리, 와 그 외의 코드에서 추상화 되어 커널에게 요청을 보냄.

이런 요청들을 시스템 콜이라고 부름.
시스템 콜의 종류 
	- 프로세스 생성, 삭제
	- 메모리 확보 해제
	- 프로세서 간 통신(ipc)
	- 네트워크
	- 파일시스템 다루기
	- 파일 다루기 

시스템콜은 cpu의 특수한 명령을 실행해야만 호출 됨.
일반적으로 cpu는 사용자 모드에서 프로세스를 관리하다가, 커널에 처리를 요청하기위해 시스템 콜을 호출하면 인터럽트 가 발생하여 cpu는 커널 모드로 변경 되 요청을 처리함 .
![](https://i.imgur.com/KS7uANw.png)


예제) 프로세스가 어떤 시스템콜을 호출 했는지는 strace 명령어를 통해 알 수 있음.
![](https://i.imgur.com/TWt2oS3.png)
예시, hello.c 

hello.o를 
strace -o hello.log ./hello 
라는 명령어로 실행하면,
![](https://i.imgur.com/42zJAFy.png)
각각의 줄은 strace는 시스템 콜 호출입니다.
그나마 익숙한 친구들 close, read, write와 같은 시스템콜들을 확인 할 수 있음

파이썬도 결국 시스템콜로 이루어져 있어서, strace를 사용하여 열람할 수 있는데, 파이썬은 사용자 편의성을 위해서 시스템이 더 복잡하므로 훨씬 더 많은 시스템콜을 호출함.
(파이썬이 c보다 느린이유)


netstat에 있는 sar 이라는 커맨드로 cpu별 프로세스 점유율을 알 수 있는데,
![](https://i.imgur.com/yLuQK2N.png)
위와 같은 커널에 접근이 없는 코드를 작성하고 
sar -P ALL 1 이라는 커맨드를 입력하면
![](https://i.imgur.com/VNCl8Bh.png)
위 처럼 두개의 cpu(가상환경이라)에서 cpu0번이 사용자모드에서 끊임없이 돌아가고 있는걸 확인 할 수 있음. (커널에 접근이 없기 때문)


![](https://i.imgur.com/8rw0nrx.png)
위와 같이 커널에 접근해 프로세스 id를 받아오는 함수를 넣으면,
![](https://i.imgur.com/HhlSecV.png)
cpu0번이 system모드에서 열심히 일하고 있는것을 알 수 있음
for문을 처리하기 위해 유저모드도 어느정도 할당되어 있는 것을 확인할 수 있음.

시스템 콜과 같은 경우는 다른 함수처럼 c와 같은 고급언어가 바로 호출 할 수 없고 어셈블리어를 사용해야 한다. 그러나 어셈블리어와 같은 경우는 벤더에 특화되어 있기 때문에 매번 함수를 고치지 않는 한 이식율등에 문제가 생김.

이를 위해서 OS에서는 시스템콜을 wrapper로 감싸 고급언어에서도 시스템콜을 효과적으로 할 수 있게 했음.

ldd라는 명령어를 통해 어떤 라이브러리를 참고하고 있는지 확인 할 수 있음
![](https://i.imgur.com/3b5Bmy0.png)
방금 만든 hello는 표준 c , libc를 참고하는 모습



